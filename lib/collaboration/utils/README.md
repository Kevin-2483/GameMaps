# åä½œå·¥å…·ç±» (Collaboration Utils)

## ğŸ“‹ æ¨¡å—èŒè´£

æä¾›åä½œç³»ç»Ÿæ‰€éœ€çš„é€šç”¨å·¥å…·ç±»ã€è¾…åŠ©å‡½æ•°ã€å¸¸é‡å®šä¹‰å’Œæ‰©å±•æ–¹æ³•ï¼Œä¸ºå…¶ä»–æ¨¡å—æä¾›åŸºç¡€æ”¯æŒåŠŸèƒ½ã€‚

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### å·¥å…·ç±»æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Collaboration Utils                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Serialization     â”‚  Encryption       â”‚  Validation    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ JSON Utils    â”‚ â”‚ â”‚ Crypto Utils  â”‚ â”‚ â”‚ Validators â”‚ â”‚
â”‚  â”‚ Binary Utils  â”‚ â”‚ â”‚ Hash Utils    â”‚ â”‚ â”‚ Sanitizers â”‚ â”‚
â”‚  â”‚ Compression   â”‚ â”‚ â”‚ Key Manager   â”‚ â”‚ â”‚ Formatters â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Time & ID Utils   â”‚  Network Utils    â”‚  Debug Utils   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ UUID Gen      â”‚ â”‚ â”‚ IP Utils      â”‚ â”‚ â”‚ Logger     â”‚ â”‚
â”‚  â”‚ Timestamp     â”‚ â”‚ â”‚ URL Utils     â”‚ â”‚ â”‚ Profiler   â”‚ â”‚
â”‚  â”‚ Clock Sync    â”‚ â”‚ â”‚ Connectivity  â”‚ â”‚ â”‚ Debugger   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è®¾è®¡åŸåˆ™
- **å¯å¤ç”¨æ€§**ï¼šæä¾›é€šç”¨çš„å·¥å…·å‡½æ•°
- **é«˜æ€§èƒ½**ï¼šä¼˜åŒ–å¸¸ç”¨æ“ä½œçš„æ€§èƒ½
- **ç±»å‹å®‰å…¨**ï¼šå¼ºç±»å‹å®šä¹‰å’ŒéªŒè¯
- **æ˜“æµ‹è¯•**ï¼šçº¯å‡½æ•°å’Œå¯æµ‹è¯•çš„è®¾è®¡
- **æ–‡æ¡£å®Œå–„**ï¼šè¯¦ç»†çš„ä½¿ç”¨è¯´æ˜å’Œç¤ºä¾‹

## ğŸ“ æ–‡ä»¶ç»“æ„

```
utils/
â”œâ”€â”€ serialization/                # åºåˆ—åŒ–å·¥å…·
â”‚   â”œâ”€â”€ json_serializer.dart
â”‚   â”œâ”€â”€ binary_serializer.dart
â”‚   â”œâ”€â”€ message_codec.dart
â”‚   â”œâ”€â”€ compression_utils.dart
â”‚   â””â”€â”€ serialization_extensions.dart
â”œâ”€â”€ encryption/                   # åŠ å¯†å·¥å…·
â”‚   â”œâ”€â”€ crypto_utils.dart
â”‚   â”œâ”€â”€ hash_utils.dart
â”‚   â”œâ”€â”€ key_manager.dart
â”‚   â”œâ”€â”€ signature_utils.dart
â”‚   â””â”€â”€ encryption_extensions.dart
â”œâ”€â”€ validation/                   # éªŒè¯å·¥å…·
â”‚   â”œâ”€â”€ validators.dart
â”‚   â”œâ”€â”€ sanitizers.dart
â”‚   â”œâ”€â”€ formatters.dart
â”‚   â”œâ”€â”€ input_validators.dart
â”‚   â””â”€â”€ data_validators.dart
â”œâ”€â”€ time/                        # æ—¶é—´å·¥å…·
â”‚   â”œâ”€â”€ time_utils.dart
â”‚   â”œâ”€â”€ timestamp_manager.dart
â”‚   â”œâ”€â”€ clock_synchronizer.dart
â”‚   â”œâ”€â”€ duration_formatter.dart
â”‚   â””â”€â”€ timezone_utils.dart
â”œâ”€â”€ id/                          # IDç”Ÿæˆå·¥å…·
â”‚   â”œâ”€â”€ uuid_generator.dart
â”‚   â”œâ”€â”€ id_utils.dart
â”‚   â”œâ”€â”€ sequence_generator.dart
â”‚   â””â”€â”€ collision_detector.dart
â”œâ”€â”€ network/                     # ç½‘ç»œå·¥å…·
â”‚   â”œâ”€â”€ network_utils.dart
â”‚   â”œâ”€â”€ ip_utils.dart
â”‚   â”œâ”€â”€ url_utils.dart
â”‚   â”œâ”€â”€ connectivity_checker.dart
â”‚   â””â”€â”€ bandwidth_calculator.dart
â”œâ”€â”€ debug/                       # è°ƒè¯•å·¥å…·
â”‚   â”œâ”€â”€ collaboration_logger.dart
â”‚   â”œâ”€â”€ performance_profiler.dart
â”‚   â”œâ”€â”€ debug_utils.dart
â”‚   â”œâ”€â”€ error_tracker.dart
â”‚   â””â”€â”€ metrics_collector.dart
â”œâ”€â”€ extensions/                  # æ‰©å±•æ–¹æ³•
â”‚   â”œâ”€â”€ string_extensions.dart
â”‚   â”œâ”€â”€ list_extensions.dart
â”‚   â”œâ”€â”€ map_extensions.dart
â”‚   â”œâ”€â”€ datetime_extensions.dart
â”‚   â””â”€â”€ stream_extensions.dart
â”œâ”€â”€ constants/                   # å¸¸é‡å®šä¹‰
â”‚   â”œâ”€â”€ collaboration_constants.dart
â”‚   â”œâ”€â”€ network_constants.dart
â”‚   â”œâ”€â”€ error_codes.dart
â”‚   â””â”€â”€ default_configs.dart
â””â”€â”€ helpers/                     # è¾…åŠ©ç±»
    â”œâ”€â”€ async_helpers.dart
    â”œâ”€â”€ collection_helpers.dart
    â”œâ”€â”€ math_helpers.dart
    â”œâ”€â”€ file_helpers.dart
    â””â”€â”€ platform_helpers.dart
```

## ğŸ”§ æ ¸å¿ƒå·¥å…·ç±»è¯´æ˜

### JsonSerializer (JSONåºåˆ—åŒ–å™¨)
**èŒè´£**ï¼šå¤„ç†åä½œæ•°æ®çš„JSONåºåˆ—åŒ–å’Œååºåˆ—åŒ–
**åŠŸèƒ½**ï¼š
- ç±»å‹å®‰å…¨çš„åºåˆ—åŒ–
- è‡ªå®šä¹‰åºåˆ—åŒ–è§„åˆ™
- æ€§èƒ½ä¼˜åŒ–
- é”™è¯¯å¤„ç†

```dart
class JsonSerializer {
  static final Map<Type, JsonConverter> _converters = {};
  
  // æ³¨å†Œè‡ªå®šä¹‰è½¬æ¢å™¨
  static void registerConverter<T>(JsonConverter<T> converter) {
    _converters[T] = converter;
  }
  
  // åºåˆ—åŒ–å¯¹è±¡
  static String serialize<T>(T object) {
    try {
      if (_converters.containsKey(T)) {
        final converter = _converters[T] as JsonConverter<T>;
        return jsonEncode(converter.toJson(object));
      }
      
      if (object is JsonSerializable) {
        return jsonEncode(object.toJson());
      }
      
      return jsonEncode(object);
    } catch (e) {
      throw SerializationException('Failed to serialize $T: $e');
    }
  }
  
  // ååºåˆ—åŒ–å¯¹è±¡
  static T deserialize<T>(String json) {
    try {
      final data = jsonDecode(json);
      
      if (_converters.containsKey(T)) {
        final converter = _converters[T] as JsonConverter<T>;
        return converter.fromJson(data);
      }
      
      throw SerializationException('No converter registered for type $T');
    } catch (e) {
      throw SerializationException('Failed to deserialize $T: $e');
    }
  }
  
  // æ‰¹é‡åºåˆ—åŒ–
  static String serializeList<T>(List<T> objects) {
    final serialized = objects.map((obj) => 
        _converters.containsKey(T) 
            ? (_converters[T] as JsonConverter<T>).toJson(obj)
            : (obj as JsonSerializable).toJson()
    ).toList();
    
    return jsonEncode(serialized);
  }
  
  // æ‰¹é‡ååºåˆ—åŒ–
  static List<T> deserializeList<T>(String json) {
    final List<dynamic> data = jsonDecode(json);
    final converter = _converters[T] as JsonConverter<T>?;
    
    if (converter == null) {
      throw SerializationException('No converter registered for type $T');
    }
    
    return data.map((item) => converter.fromJson(item)).toList();
  }
}

// è‡ªå®šä¹‰è½¬æ¢å™¨æ¥å£
abstract class JsonConverter<T> {
  Map<String, dynamic> toJson(T object);
  T fromJson(Map<String, dynamic> json);
}

// å¯åºåˆ—åŒ–æ¥å£
abstract class JsonSerializable {
  Map<String, dynamic> toJson();
}

// æ“ä½œè½¬æ¢å™¨ç¤ºä¾‹
class OperationConverter implements JsonConverter<Operation> {
  @override
  Map<String, dynamic> toJson(Operation operation) {
    return {
      'id': operation.id,
      'type': operation.runtimeType.toString(),
      'clientId': operation.clientId,
      'timestamp': operation.timestamp.toIso8601String(),
      'vectorClock': operation.vectorClock.toJson(),
      'data': _serializeOperationData(operation),
    };
  }
  
  @override
  Operation fromJson(Map<String, dynamic> json) {
    final type = json['type'] as String;
    final data = json['data'] as Map<String, dynamic>;
    
    switch (type) {
      case 'InsertOperation':
        return InsertOperation.fromJson(json, data);
      case 'UpdateOperation':
        return UpdateOperation.fromJson(json, data);
      case 'DeleteOperation':
        return DeleteOperation.fromJson(json, data);
      default:
        throw SerializationException('Unknown operation type: $type');
    }
  }
  
  Map<String, dynamic> _serializeOperationData(Operation operation) {
    if (operation is InsertOperation) {
      return {
        'elementId': operation.elementId,
        'element': operation.element.toJson(),
        'position': operation.position,
      };
    } else if (operation is UpdateOperation) {
      return {
        'elementId': operation.elementId,
        'changes': operation.changes,
      };
    } else if (operation is DeleteOperation) {
      return {
        'elementId': operation.elementId,
      };
    }
    
    throw SerializationException('Unsupported operation type: ${operation.runtimeType}');
  }
}
```

### CompressionUtils (å‹ç¼©å·¥å…·)
**èŒè´£**ï¼šæ•°æ®å‹ç¼©å’Œè§£å‹ç¼©
**åŠŸèƒ½**ï¼š
- å¤šç§å‹ç¼©ç®—æ³•æ”¯æŒ
- è‡ªé€‚åº”å‹ç¼©ç­–ç•¥
- æ€§èƒ½ç›‘æ§
- å‹ç¼©ç‡ç»Ÿè®¡

```dart
class CompressionUtils {
  static const int _compressionThreshold = 1024; // 1KB
  
  // å‹ç¼©æ•°æ®
  static Uint8List compress(
    Uint8List data, {
    CompressionLevel level = CompressionLevel.balanced,
    CompressionAlgorithm algorithm = CompressionAlgorithm.gzip,
  }) {
    if (data.length < _compressionThreshold) {
      return data; // å°æ•°æ®ä¸å‹ç¼©
    }
    
    switch (algorithm) {
      case CompressionAlgorithm.gzip:
        return _compressGzip(data, level);
      case CompressionAlgorithm.deflate:
        return _compressDeflate(data, level);
      case CompressionAlgorithm.lz4:
        return _compressLZ4(data, level);
      default:
        throw UnsupportedError('Unsupported compression algorithm: $algorithm');
    }
  }
  
  // è§£å‹ç¼©æ•°æ®
  static Uint8List decompress(
    Uint8List compressedData,
    CompressionAlgorithm algorithm,
  ) {
    switch (algorithm) {
      case CompressionAlgorithm.gzip:
        return _decompressGzip(compressedData);
      case CompressionAlgorithm.deflate:
        return _decompressDeflate(compressedData);
      case CompressionAlgorithm.lz4:
        return _decompressLZ4(compressedData);
      default:
        throw UnsupportedError('Unsupported compression algorithm: $algorithm');
    }
  }
  
  // è‡ªé€‚åº”å‹ç¼©
  static CompressionResult adaptiveCompress(Uint8List data) {
    if (data.length < _compressionThreshold) {
      return CompressionResult(
        data: data,
        algorithm: CompressionAlgorithm.none,
        originalSize: data.length,
        compressedSize: data.length,
        compressionRatio: 1.0,
      );
    }
    
    // å°è¯•ä¸åŒç®—æ³•ï¼Œé€‰æ‹©æœ€ä½³ç»“æœ
    final results = <CompressionResult>[];
    
    for (final algorithm in CompressionAlgorithm.values) {
      if (algorithm == CompressionAlgorithm.none) continue;
      
      try {
        final compressed = compress(data, algorithm: algorithm);
        results.add(CompressionResult(
          data: compressed,
          algorithm: algorithm,
          originalSize: data.length,
          compressedSize: compressed.length,
          compressionRatio: compressed.length / data.length,
        ));
      } catch (e) {
        // å¿½ç•¥å¤±è´¥çš„ç®—æ³•
      }
    }
    
    // é€‰æ‹©å‹ç¼©ç‡æœ€å¥½çš„ç»“æœ
    results.sort((a, b) => a.compressionRatio.compareTo(b.compressionRatio));
    return results.isNotEmpty ? results.first : CompressionResult(
      data: data,
      algorithm: CompressionAlgorithm.none,
      originalSize: data.length,
      compressedSize: data.length,
      compressionRatio: 1.0,
    );
  }
  
  static Uint8List _compressGzip(Uint8List data, CompressionLevel level) {
    final codec = GZipCodec(level: _mapCompressionLevel(level));
    return Uint8List.fromList(codec.encode(data));
  }
  
  static Uint8List _decompressGzip(Uint8List data) {
    final codec = GZipCodec();
    return Uint8List.fromList(codec.decode(data));
  }
  
  static int _mapCompressionLevel(CompressionLevel level) {
    switch (level) {
      case CompressionLevel.fast:
        return 1;
      case CompressionLevel.balanced:
        return 6;
      case CompressionLevel.best:
        return 9;
    }
  }
}

enum CompressionAlgorithm {
  none,
  gzip,
  deflate,
  lz4,
}

enum CompressionLevel {
  fast,
  balanced,
  best,
}

class CompressionResult {
  final Uint8List data;
  final CompressionAlgorithm algorithm;
  final int originalSize;
  final int compressedSize;
  final double compressionRatio;
  
  CompressionResult({
    required this.data,
    required this.algorithm,
    required this.originalSize,
    required this.compressedSize,
    required this.compressionRatio,
  });
  
  double get spaceSaved => 1.0 - compressionRatio;
  bool get isCompressed => algorithm != CompressionAlgorithm.none;
}
```

### UuidGenerator (UUIDç”Ÿæˆå™¨)
**èŒè´£**ï¼šç”Ÿæˆå”¯ä¸€æ ‡è¯†ç¬¦
**åŠŸèƒ½**ï¼š
- å¤šç§UUIDç‰ˆæœ¬æ”¯æŒ
- å†²çªæ£€æµ‹
- æ€§èƒ½ä¼˜åŒ–
- è‡ªå®šä¹‰å‰ç¼€æ”¯æŒ

```dart
class UuidGenerator {
  static final Random _random = Random.secure();
  static final Set<String> _usedIds = <String>{};
  static const int _maxRetries = 10;
  
  // ç”ŸæˆUUID v4
  static String generateV4({String? prefix}) {
    for (int attempt = 0; attempt < _maxRetries; attempt++) {
      final uuid = _generateUuidV4();
      final id = prefix != null ? '$prefix-$uuid' : uuid;
      
      if (!_usedIds.contains(id)) {
        _usedIds.add(id);
        return id;
      }
    }
    
    throw Exception('Failed to generate unique UUID after $_maxRetries attempts');
  }
  
  // ç”ŸæˆçŸ­IDï¼ˆç”¨äºä¸´æ—¶æ ‡è¯†ï¼‰
  static String generateShortId({int length = 8}) {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    
    for (int attempt = 0; attempt < _maxRetries; attempt++) {
      final id = String.fromCharCodes(Iterable.generate(
        length,
        (_) => chars.codeUnitAt(_random.nextInt(chars.length)),
      ));
      
      if (!_usedIds.contains(id)) {
        _usedIds.add(id);
        return id;
      }
    }
    
    throw Exception('Failed to generate unique short ID after $_maxRetries attempts');
  }
  
  // ç”Ÿæˆæ—¶é—´æˆ³ID
  static String generateTimestampId({String? prefix}) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final random = _random.nextInt(0xFFFF).toRadixString(16).padLeft(4, '0');
    final id = '$timestamp-$random';
    
    return prefix != null ? '$prefix-$id' : id;
  }
  
  // ç”Ÿæˆåºåˆ—ID
  static String generateSequenceId(String category) {
    final sequence = SequenceGenerator.getNext(category);
    return '$category-${sequence.toString().padLeft(6, '0')}';
  }
  
  // éªŒè¯IDæ ¼å¼
  static bool isValidUuid(String id) {
    final uuidRegex = RegExp(
      r'^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$',
      caseSensitive: false,
    );
    return uuidRegex.hasMatch(id);
  }
  
  // æ¸…ç†å·²ä½¿ç”¨çš„IDï¼ˆå®šæœŸæ¸…ç†ä»¥é˜²å†…å­˜æ³„æ¼ï¼‰
  static void cleanup() {
    if (_usedIds.length > 10000) {
      _usedIds.clear();
    }
  }
  
  static String _generateUuidV4() {
    final bytes = Uint8List(16);
    for (int i = 0; i < 16; i++) {
      bytes[i] = _random.nextInt(256);
    }
    
    // è®¾ç½®ç‰ˆæœ¬å· (4) å’Œå˜ä½“ä½
    bytes[6] = (bytes[6] & 0x0f) | 0x40;
    bytes[8] = (bytes[8] & 0x3f) | 0x80;
    
    return _formatUuid(bytes);
  }
  
  static String _formatUuid(Uint8List bytes) {
    final hex = bytes.map((b) => b.toRadixString(16).padLeft(2, '0')).join();
    return '${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20, 32)}';
  }
}

class SequenceGenerator {
  static final Map<String, int> _sequences = {};
  
  static int getNext(String category) {
    _sequences[category] = (_sequences[category] ?? 0) + 1;
    return _sequences[category]!;
  }
  
  static int getCurrent(String category) {
    return _sequences[category] ?? 0;
  }
  
  static void reset(String category) {
    _sequences[category] = 0;
  }
  
  static void resetAll() {
    _sequences.clear();
  }
}
```

### CollaborationLogger (åä½œæ—¥å¿—å™¨)
**èŒè´£**ï¼šåä½œç³»ç»Ÿçš„æ—¥å¿—è®°å½•å’Œè°ƒè¯•
**åŠŸèƒ½**ï¼š
- åˆ†çº§æ—¥å¿—è®°å½•
- æ€§èƒ½ç›‘æ§
- é”™è¯¯è¿½è¸ª
- æ—¥å¿—è¿‡æ»¤å’Œæœç´¢

```dart
class CollaborationLogger {
  static final CollaborationLogger _instance = CollaborationLogger._internal();
  factory CollaborationLogger() => _instance;
  CollaborationLogger._internal();
  
  final List<LogEntry> _logs = [];
  final StreamController<LogEntry> _logController = StreamController.broadcast();
  LogLevel _minLevel = LogLevel.info;
  bool _enabled = true;
  
  Stream<LogEntry> get logs => _logController.stream;
  
  // é…ç½®æ—¥å¿—å™¨
  void configure({
    LogLevel? minLevel,
    bool? enabled,
    int? maxLogEntries,
  }) {
    if (minLevel != null) _minLevel = minLevel;
    if (enabled != null) _enabled = enabled;
    if (maxLogEntries != null && _logs.length > maxLogEntries) {
      _logs.removeRange(0, _logs.length - maxLogEntries);
    }
  }
  
  // è®°å½•æ—¥å¿—
  void log(
    LogLevel level,
    String message, {
    String? category,
    Map<String, dynamic>? data,
    Object? error,
    StackTrace? stackTrace,
  }) {
    if (!_enabled || level.index < _minLevel.index) return;
    
    final entry = LogEntry(
      level: level,
      message: message,
      category: category ?? 'General',
      timestamp: DateTime.now(),
      data: data,
      error: error,
      stackTrace: stackTrace,
    );
    
    _logs.add(entry);
    _logController.add(entry);
    
    // è¾“å‡ºåˆ°æ§åˆ¶å°ï¼ˆå¼€å‘æ¨¡å¼ï¼‰
    if (kDebugMode) {
      _printToConsole(entry);
    }
  }
  
  // ä¾¿æ·æ–¹æ³•
  void debug(String message, {String? category, Map<String, dynamic>? data}) {
    log(LogLevel.debug, message, category: category, data: data);
  }
  
  void info(String message, {String? category, Map<String, dynamic>? data}) {
    log(LogLevel.info, message, category: category, data: data);
  }
  
  void warning(String message, {String? category, Map<String, dynamic>? data}) {
    log(LogLevel.warning, message, category: category, data: data);
  }
  
  void error(
    String message, {
    String? category,
    Object? error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    log(
      LogLevel.error,
      message,
      category: category,
      error: error,
      stackTrace: stackTrace,
      data: data,
    );
  }
  
  // æ€§èƒ½ç›‘æ§
  PerformanceTimer startTimer(String operation, {String? category}) {
    return PerformanceTimer._(this, operation, category);
  }
  
  // æœç´¢æ—¥å¿—
  List<LogEntry> search({
    String? query,
    LogLevel? level,
    String? category,
    DateTime? startTime,
    DateTime? endTime,
  }) {
    return _logs.where((entry) {
      if (level != null && entry.level != level) return false;
      if (category != null && entry.category != category) return false;
      if (startTime != null && entry.timestamp.isBefore(startTime)) return false;
      if (endTime != null && entry.timestamp.isAfter(endTime)) return false;
      if (query != null && !entry.message.toLowerCase().contains(query.toLowerCase())) {
        return false;
      }
      return true;
    }).toList();
  }
  
  // å¯¼å‡ºæ—¥å¿—
  String exportLogs({
    LogLevel? minLevel,
    String? category,
    DateTime? startTime,
    DateTime? endTime,
  }) {
    final filteredLogs = search(
      level: minLevel,
      category: category,
      startTime: startTime,
      endTime: endTime,
    );
    
    return filteredLogs.map((entry) => entry.toString()).join('\n');
  }
  
  void _printToConsole(LogEntry entry) {
    final timestamp = entry.timestamp.toIso8601String();
    final level = entry.level.name.toUpperCase();
    final category = entry.category;
    final message = entry.message;
    
    print('[$timestamp] [$level] [$category] $message');
    
    if (entry.data != null) {
      print('  Data: ${entry.data}');
    }
    
    if (entry.error != null) {
      print('  Error: ${entry.error}');
    }
    
    if (entry.stackTrace != null) {
      print('  Stack Trace: ${entry.stackTrace}');
    }
  }
}

enum LogLevel {
  debug,
  info,
  warning,
  error,
}

class LogEntry {
  final LogLevel level;
  final String message;
  final String category;
  final DateTime timestamp;
  final Map<String, dynamic>? data;
  final Object? error;
  final StackTrace? stackTrace;
  
  LogEntry({
    required this.level,
    required this.message,
    required this.category,
    required this.timestamp,
    this.data,
    this.error,
    this.stackTrace,
  });
  
  @override
  String toString() {
    final buffer = StringBuffer();
    buffer.write('[${timestamp.toIso8601String()}] ');
    buffer.write('[${level.name.toUpperCase()}] ');
    buffer.write('[$category] ');
    buffer.write(message);
    
    if (data != null) {
      buffer.write(' | Data: $data');
    }
    
    if (error != null) {
      buffer.write(' | Error: $error');
    }
    
    return buffer.toString();
  }
}

class PerformanceTimer {
  final CollaborationLogger _logger;
  final String _operation;
  final String? _category;
  final Stopwatch _stopwatch;
  
  PerformanceTimer._(
    this._logger,
    this._operation,
    this._category,
  ) : _stopwatch = Stopwatch()..start();
  
  void stop({Map<String, dynamic>? additionalData}) {
    _stopwatch.stop();
    
    final data = <String, dynamic>{
      'operation': _operation,
      'duration_ms': _stopwatch.elapsedMilliseconds,
      'duration_us': _stopwatch.elapsedMicroseconds,
    };
    
    if (additionalData != null) {
      data.addAll(additionalData);
    }
    
    _logger.info(
      'Performance: $_operation completed in ${_stopwatch.elapsedMilliseconds}ms',
      category: _category ?? 'Performance',
      data: data,
    );
  }
}
```

## ğŸ”§ æ‰©å±•æ–¹æ³•

### StringExtensions (å­—ç¬¦ä¸²æ‰©å±•)
```dart
extension StringExtensions on String {
  // éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ç”¨æˆ·ID
  bool get isValidClientId {
    return RegExp(r'^[a-zA-Z0-9_-]{3,50}$').hasMatch(this);
  }
  
  // éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„æˆ¿é—´ID
  bool get isValidRoomId {
    return RegExp(r'^[a-zA-Z0-9_-]{6,100}$').hasMatch(this);
  }
  
  // æˆªæ–­å­—ç¬¦ä¸²
  String truncate(int maxLength, {String suffix = '...'}) {
    if (length <= maxLength) return this;
    return '${substring(0, maxLength - suffix.length)}$suffix';
  }
  
  // å®‰å…¨çš„JSONè§£æ
  Map<String, dynamic>? tryParseJson() {
    try {
      return jsonDecode(this) as Map<String, dynamic>;
    } catch (e) {
      return null;
    }
  }
  
  // è®¡ç®—å­—ç¬¦ä¸²å“ˆå¸Œ
  int get fastHash {
    int hash = 0;
    for (int i = 0; i < length; i++) {
      hash = ((hash << 5) - hash + codeUnitAt(i)) & 0xffffffff;
    }
    return hash;
  }
}
```

### ListExtensions (åˆ—è¡¨æ‰©å±•)
```dart
extension ListExtensions<T> on List<T> {
  // å®‰å…¨è·å–å…ƒç´ 
  T? safeGet(int index) {
    return index >= 0 && index < length ? this[index] : null;
  }
  
  // æ‰¹é‡å¤„ç†
  List<List<T>> batch(int size) {
    final batches = <List<T>>[];
    for (int i = 0; i < length; i += size) {
      batches.add(sublist(i, math.min(i + size, length)));
    }
    return batches;
  }
  
  // å»é‡ï¼ˆä¿æŒé¡ºåºï¼‰
  List<T> distinctBy<K>(K Function(T) keySelector) {
    final seen = <K>{};
    return where((element) => seen.add(keySelector(element))).toList();
  }
  
  // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹ï¼ˆå¯ç©ºï¼‰
  T? firstWhereOrNull(bool Function(T) test) {
    for (final element in this) {
      if (test(element)) return element;
    }
    return null;
  }
}
```

## ğŸ“Š å¸¸é‡å®šä¹‰

### CollaborationConstants (åä½œå¸¸é‡)
```dart
class CollaborationConstants {
  // ç½‘ç»œé…ç½®
  static const Duration defaultConnectionTimeout = Duration(seconds: 10);
  static const Duration defaultHeartbeatInterval = Duration(seconds: 30);
  static const int maxConcurrentConnections = 100;
  static const int maxMessageSize = 64 * 1024; // 64KB
  
  // åŒæ­¥é…ç½®
  static const Duration syncBatchInterval = Duration(milliseconds: 100);
  static const int maxPendingOperations = 1000;
  static const Duration operationTimeout = Duration(seconds: 30);
  
  // UIé…ç½®
  static const Duration animationDuration = Duration(milliseconds: 300);
  static const Duration notificationDuration = Duration(seconds: 5);
  static const int maxVisibleUsers = 10;
  
  // æ€§èƒ½é…ç½®
  static const int compressionThreshold = 1024; // 1KB
  static const Duration performanceLogInterval = Duration(minutes: 1);
  static const int maxLogEntries = 10000;
}

class ErrorCodes {
  // ç½‘ç»œé”™è¯¯
  static const String connectionFailed = 'CONN_FAILED';
  static const String connectionTimeout = 'CONN_TIMEOUT';
  static const String networkUnavailable = 'NET_UNAVAILABLE';
  
  // åŒæ­¥é”™è¯¯
  static const String syncFailed = 'SYNC_FAILED';
  static const String conflictResolutionFailed = 'CONFLICT_FAILED';
  static const String operationInvalid = 'OP_INVALID';
  
  // è®¤è¯é”™è¯¯
  static const String authenticationFailed = 'AUTH_FAILED';
  static const String permissionDenied = 'PERM_DENIED';
  static const String sessionExpired = 'SESSION_EXPIRED';
  
  // æ•°æ®é”™è¯¯
  static const String serializationFailed = 'SERIAL_FAILED';
  static const String dataCorrupted = 'DATA_CORRUPT';
  static const String versionMismatch = 'VERSION_MISMATCH';
}
```

## ğŸ§ª æµ‹è¯•å·¥å…·

### TestUtils (æµ‹è¯•å·¥å…·)
```dart
class TestUtils {
  // ç”Ÿæˆæµ‹è¯•æ•°æ®
  static NodeInfo generateTestNode(String id) {
    return NodeInfo(
      id: id,
      networkQuality: NetworkQuality.good(),
      cpuPerformance: 0.8,
      bandwidth: 50.0,
      stability: 0.9,
      uptime: Duration(hours: 2),
    );
  }
  
  static List<NodeInfo> generateTestNodes(int count) {
    return List.generate(count, (i) => generateTestNode('node$i'));
  }
  
  static Operation generateTestOperation(String clientId) {
    return UpdateOperation(
      id: UuidGenerator.generateV4(),
      elementId: 'element_${Random().nextInt(100)}',
      changes: {'color': 'red', 'size': Random().nextInt(100)},
      clientId: clientId,
      timestamp: DateTime.now(),
      vectorClock: VectorClock(),
    );
  }
  
  // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
  static Future<void> simulateNetworkDelay([Duration? delay]) {
    return Future.delayed(delay ?? Duration(milliseconds: Random().nextInt(100)));
  }
  
  // æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯
  static void simulateNetworkError({double probability = 0.1}) {
    if (Random().nextDouble() < probability) {
      throw NetworkException('Simulated network error');
    }
  }
}
```

## ğŸ“‹ å¼€å‘æ¸…å•

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€å·¥å…·
- [ ] JsonSerializeråºåˆ—åŒ–å™¨
- [ ] UuidGenerator IDç”Ÿæˆå™¨
- [ ] CollaborationLoggeræ—¥å¿—å™¨
- [ ] åŸºç¡€æ‰©å±•æ–¹æ³•

### ç¬¬äºŒé˜¶æ®µï¼šé«˜çº§å·¥å…·
- [ ] CompressionUtilså‹ç¼©å·¥å…·
- [ ] CryptoUtilsåŠ å¯†å·¥å…·
- [ ] NetworkUtilsç½‘ç»œå·¥å…·
- [ ] éªŒè¯å’Œæ ¼å¼åŒ–å·¥å…·

### ç¬¬ä¸‰é˜¶æ®µï¼šæ€§èƒ½å·¥å…·
- [ ] PerformanceProfileræ€§èƒ½åˆ†æå™¨
- [ ] MetricsCollectoræŒ‡æ ‡æ”¶é›†å™¨
- [ ] DebugUtilsè°ƒè¯•å·¥å…·
- [ ] æµ‹è¯•è¾…åŠ©å·¥å…·

### ç¬¬å››é˜¶æ®µï¼šå®Œå–„å’Œä¼˜åŒ–
- [ ] æ›´å¤šæ‰©å±•æ–¹æ³•
- [ ] å¹³å°ç‰¹å®šå·¥å…·
- [ ] æ–‡æ¡£å’Œç¤ºä¾‹
- [ ] æ€§èƒ½ä¼˜åŒ–

## ğŸ”— ä¾èµ–å…³ç³»

- **ä¸Šæ¸¸ä¾èµ–**ï¼šæ— ï¼ˆåŸºç¡€æ¨¡å—ï¼‰
- **ä¸‹æ¸¸ä¾èµ–**ï¼šæ‰€æœ‰å…¶ä»–åä½œæ¨¡å—
- **å¤–éƒ¨ä¾èµ–**ï¼šcrypto, uuid
- **ç³»ç»Ÿä¾èµ–**ï¼šdart:io, dart:convert

## ğŸ“ å¼€å‘è§„èŒƒ

1. **çº¯å‡½æ•°ä¼˜å…ˆ**ï¼šå°½é‡ä½¿ç”¨çº¯å‡½æ•°ï¼Œä¾¿äºæµ‹è¯•
2. **ç±»å‹å®‰å…¨**ï¼šä½¿ç”¨å¼ºç±»å‹å®šä¹‰ï¼Œé¿å…dynamic
3. **æ€§èƒ½è€ƒè™‘**ï¼šä¼˜åŒ–å¸¸ç”¨æ“ä½œçš„æ€§èƒ½
4. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œé”™è¯¯ä¿¡æ¯
5. **æ–‡æ¡£å®Œå–„**ï¼šæ¯ä¸ªå·¥å…·ç±»éƒ½è¦æœ‰è¯¦ç»†æ–‡æ¡£
6. **æµ‹è¯•è¦†ç›–**ï¼šç¡®ä¿é«˜æµ‹è¯•è¦†ç›–ç‡